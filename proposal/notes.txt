INTRODUCTION - 3 PAGES ??

uprobes, kprobe not not possible with tracing KVM from host




\subsection{The Semantic Gap Problem}

{\large
The primary advantage of in-VM systems is their direct access to all kinds of OS level abstractions like files, and processes.


However, when using a hypervisor-based VMI system, access to all of the rich semantic abstractions that the OS provides is lost. Although hypervisors have a grand view of the entire state of the VMs they monitor, this grand view unfortunately is provided with hardware-level abstractions, which consists ones and zeros, putting a disadvantage to a humans due to providing no context. The disparity between OS and hardware level abstractions is known as the semantic gap. As we are using a hypervisor-based VMI, guest system call and process information can only be detected based on register values.

As an example of how the semantic gap creates challenges for introspection, consider how a hypervisor might
go about listing the processes running in a guest OS. The hypervisor can access only hardware-level abstractions, such
as the CPU registers and contents of guest memory pages. The hypervisor must identify specific regions of guest OS memory that include process descriptors, and interpret the raw bytes to reconstruct semantic information, such as the
command line, user id, and scheduling priorities.
\newline
}


\subsection{Inability to Trace KVM Guest System Calls from the KVM Hypervisor}

{\large
One of the problems with hypervisor-based VMI systems is that not all the guest events result in the guest trapping to the hypervisor. For instance, guest system calls do not result in the guest trapping to the hypervisor. For this reason, by default, it is not possible to trace system call KVM VMs from the hypervisor. For this reason, it is not feasible for eBPF to observe guest system calls.
\newline
}





\section{The Problem with Hypervisor based VMI's}

{\large
The problems we face are strongly related to the six research questions we previously proposed.
\newline
}



\subsection{Approaching the KVM Hypervisors inability to Trace Guest System Calls}

{\large
To observe system calls from the guest operating system, we must force system call instructions to result in a VM Exit. To achieve this, we must unset the system call enable (SCE) bit of the guest VMs Extended Feature Enable Register (EFER), which is a Model Specific Register (MSR). Unsetting this bit results in system call instructions being unknown to the CPU. As a consequence, when system call instructions are executed in guest VMs, an invalid opcode exception (\#UD) is generated that induces a VM Exit with exit reason zero. From this point, eBPF can be used to observe VM Exits from the host, and the RIP register can be used to verify that the VM Exit with reason 0 was due to a system call instruction. As unsetting the SCE bit results in system call instructions to be unknown by the CPU, we will need to explictly emulate every system call instruction in the hypervisor before making an entry back into the VM.
\newline
}





\section{Disadvantage to our Design}

Model specific registers are used to provide access to features that are generally tied to implementation dependent aspects of a particular processor.The features provided by the model specific registers are expected to change from processor
generation to processor generation and may even change from model to model within the same
generation. Because these features are implementation dependent, they are not recommended for
use in portable software. Specifically, software developers should not expect that the features
implemented within the MSRs will be supported in an upward or downward compatible manner
across generations or even across different models within the same generation.

\chapter{Conclusion}




\chapter{Threat Model of Frail}